<!DOCTYPE html>
<html>
<head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
  <meta content="utf-8" http-equiv="encoding">
  <title>Default WebGL!</title>
  <style>
    html, body {
      background: url('https://cs460.org/assignments/04/bg.jpg');
      background-size: cover;
      margin: 0; padding: 0; height: 100%;
      overflow: hidden !important;
    }
    #c { width: 100%; height: 100%; }
    #bubble {
        position: absolute;
        left: 45%;
        top: 30%;
        padding: 16px 24px;
        font: 800 24px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        background: rgba(255,255,255,0.95);
        border-radius: 20px;
        box-shadow: 0 8px 20px rgba(0,0,0,0.25);
        transform: translate(-50%, -100%);
        white-space: nowrap;
        pointer-events: none;
    }
    #bubble::after {
        content: "";
        position: absolute;
        left: 50%;        
        bottom: -12px;              
        transform: translateX(-50%);
        width: 0; height: 0;
        border-left: 12px solid transparent;
        border-right: 12px solid transparent;
        border-top: 12px solid rgba(255,255,255,0.95); 
        filter: drop-shadow(0 3px 0 rgba(0,0,0,0.1));
    }
    #play-btn {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 18px;
        font: 600 16px system-ui, sans-serif;
        border: none;
        border-radius: 10px;
        background: rgba(255,255,255,0.85);
        box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        cursor: pointer;
    }
    #play-btn:hover { 
        background: rgba(255,255,255,1); 
    }

  </style>
</head>

<canvas id="c"></canvas>
<div id="bubble">Party under the sea!</div>
<button id="play-btn">Play Music ðŸŽ¶</button>
<audio id="bg-music" src="https://ia601901.us.archive.org/7/items/01.UnderTheSeaTheLittleMermaid/01.%20Under%20the%20Sea%20-%20The%20Little%20Mermaid.mp3" autoplay muted loop preload="none"></audio>


<script type="text/javascript" src="https://cs460.org/js/glmatrix.js"></script>

<script id="vertexshader" type="glsl">
  attribute vec3 a_position;
  uniform float u_pointsize;
  uniform mat4 u_transform;
  void main(void) {
    vec4 final_position = u_transform * vec4(a_position, 1.);
    gl_Position = final_position;
    gl_PointSize = u_pointsize;
  }
</script>

<script id="fragmentshader" type="glsl">
  precision mediump float;
  uniform vec4 u_color;
  uniform int u_eyeShape;
  void main(void) {
    if (u_eyeShape == 1) {
      float d = distance(gl_PointCoord, vec2(0.5));
      if (d > 0.5) discard;
    }
    gl_FragColor = u_color;
  }
</script>

<script>
  var c, gl;
  var v_shader, f_shader, shaderprogram;
  var all_fish = [];

  window.onload = function () {
    // Canvas + GL
    c = document.getElementById('c');
    c.width = window.innerWidth; c.height = window.innerHeight;
    gl = c.getContext('webgl');
    gl.viewport(0, 0, c.width, c.height);

    // Shaders
    v_shader = gl.createShader(gl.VERTEX_SHADER);
    f_shader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(v_shader, document.getElementById('vertexshader').innerText);
    gl.compileShader(v_shader);
    if (!gl.getShaderParameter(v_shader, gl.COMPILE_STATUS)) {
      console.log(gl.getShaderInfoLog(v_shader));
    }
    gl.shaderSource(f_shader, document.getElementById('fragmentshader').innerText);
    gl.compileShader(f_shader);
    if (!gl.getShaderParameter(f_shader, gl.COMPILE_STATUS)) {
      console.log(gl.getShaderInfoLog(f_shader));
    }
    shaderprogram = gl.createProgram();
    gl.attachShader(shaderprogram, v_shader);
    gl.attachShader(shaderprogram, f_shader);
    gl.linkProgram(shaderprogram);
    gl.useProgram(shaderprogram);

    // Fish
    all_fish.push(createFish(new Float32Array([0, 0, 0]), new Float32Array([1., 0.55, 0., 1.]), 0.8, -1));
    for (var i = 0; i < 100; i++) {
      var random_color = [Math.random(), Math.random(), Math.random(), Math.random()];
      var random_offset = [Math.random() - Math.random(), Math.random() - Math.random(), 0];
      var random_scale = Math.random() * 0.3;
      all_fish.push(createFish(random_offset, random_color, random_scale, 1));
    }

    animate();
  };

  function createFish(offset, color, scale, direction) {
    // Body vertices
    var vertices = new Float32Array([
      0.4,  0.0, 0.0,   // 0 nose
      0.1,  0.25, 0.0,  // 1 upper body
     -0.2,  0.08, 0.0,  // 2 upper tail base
     -0.4,  0.3, 0.0,   // 3 upper tail tip
     -0.4, -0.3, 0.0,   // 4 lower tail tip
     -0.2, -0.08, 0.0,  // 5 lower tail base
      0.1, -0.25, 0.0,   // 6 lower body
        -0.3, 0.0, 0.0
    ]);

    var indices = new Uint8Array([
      0,1,6,  1,2,6,  2,5,6,  2,7,3,  5,4,7,  2,7,5
    ]);

    // Eye (point)
    var eye_vertex = new Float32Array([0.1, 0.1, 0.0]);
    if (direction == -1) {
      eye_vertex = new Float32Array([0.17, -0.1, 0.0]);
    }

    // Mouth (arc near the nose)
    // Center a bit behind/under the nose; arc angles give a "smile"
    var mouthCenter = [0.18, 0.09, 0.0];
    var mouthRadius = -0.03;
    var startDeg = 250.0;
    var endDeg   = 380.0;
    var mouthSegments = 24;
    var mouthVerts = [];
    for (var i = 0; i <= mouthSegments; i++) {
      var t = startDeg + (endDeg - startDeg) * (i / mouthSegments);
      var rad = t * Math.PI / 180.0;
      mouthVerts.push(
        mouthCenter[0] + mouthRadius * Math.cos(rad),
        mouthCenter[1] + mouthRadius * Math.sin(rad),
        0.0
      );
    }
    var mouth_vertex = new Float32Array(mouthVerts);

    // Buffers
    var v_buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, v_buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    var i_buffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, i_buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

    var eye_v_buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, eye_v_buffer);
    gl.bufferData(gl.ARRAY_BUFFER, eye_vertex, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    var mouth_v_buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, mouth_v_buffer);
    gl.bufferData(gl.ARRAY_BUFFER, mouth_vertex, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    // IMPORTANT: keep existing indices the same, append new stuff at the end
    // [0]=v_buffer, [1]=i_buffer, [2]=eye_v_buffer, [3]=offset, [4]=color, [5]=scale, [6]=direction
    // append: [7]=mouth_v_buffer, [8]=mouth_count
    return [v_buffer, i_buffer, eye_v_buffer, offset, color, scale, direction, mouth_v_buffer, mouth_vertex.length / 3];
  }

  function animate() {
    requestAnimationFrame(animate);

    gl.clearColor(0., 0., 0., 0.);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.disable(gl.DEPTH_TEST);

    for (var r = 0; r < all_fish.length; r++) {
      var current_buffers = all_fish[r];
      var current_v_buffer   = current_buffers[0];
      var current_i_buffer   = current_buffers[1];
      var current_eye_v_buf  = current_buffers[2];
      var current_offset     = current_buffers[3];
      var current_color      = current_buffers[4];
      var current_scale      = current_buffers[5];
      var current_direction  = current_buffers[6];
      var current_mouth_buf  = current_buffers[7];
      var current_mouth_count= current_buffers[8];

      // Motion
      var frequencyY = 0.8;
      var phaseY = r * 0.6;
      var t = performance.now() * 0.01;

      current_offset[0] += 0.003 * current_direction;
      current_offset[1] += 0.005 * Math.sin(t * frequencyY + phaseY);
      if (current_offset[0] >= 1.1) { current_direction = -1; }
      current_offset[0] *= current_direction;

      var theta = 0.05 * Math.sin(t * 0.4 + r * 0.7);

      let transform = [
        current_direction*current_scale*Math.cos(theta),  Math.sin(theta), 0, 0,
       -Math.sin(theta), current_direction*current_scale*Math.cos(theta), 0, 0,
        0, 0, current_direction*current_scale*1, 0,
        current_offset[0], current_offset[1], current_offset[2], 1
      ];

      // Attributes/uniforms
      gl.bindBuffer(gl.ARRAY_BUFFER, current_v_buffer);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, current_i_buffer);

      var a_position = gl.getAttribLocation(shaderprogram, 'a_position');
      gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(a_position);

      var u_transform = gl.getUniformLocation(shaderprogram, 'u_transform');
      gl.uniformMatrix4fv(u_transform, false, new Float32Array(transform));

      var u_color = gl.getUniformLocation(shaderprogram, 'u_color');
      var u_eyeShape = gl.getUniformLocation(shaderprogram, 'u_eyeShape');

      // Color pulsing (keep first fish red)
      var a = 0.6 + 0.4 * Math.sin(t * 2.0);
      current_color = new Float32Array([
        0.3 + 0.2*Math.sin(t + 0.0),
        0.6 + 0.2*Math.sin(t + 2.0),
        0.9 + 0.1*Math.sin(t + 4.0),
        a
      ]);
      if (r == 0) current_color = [1, 0, 0, .7];

      gl.uniform1i(u_eyeShape, 0);
      gl.uniform4fv(u_color, current_color);

      // Body
      gl.drawElements(gl.TRIANGLES, 18, gl.UNSIGNED_BYTE, 0);

      // Eye
      gl.uniform1i(u_eyeShape, 1);
      gl.uniform4fv(u_color, new Float32Array([0, 0, 0, .5]));
      var u_pointsize = gl.getUniformLocation(shaderprogram, 'u_pointsize');
      gl.uniform1fv(u_pointsize, new Float32Array([current_scale * 20.]));
      gl.bindBuffer(gl.ARRAY_BUFFER, current_eye_v_buf);
      gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(a_position);
      gl.drawArrays(gl.POINTS, 0, 1);

      // Mouth (smile arc)
      if (r === 0) {
        gl.uniform1i(u_eyeShape, 0); // normal fragment mode
        gl.uniform4fv(u_color, new Float32Array([0, 0, 0, 0.8]));
        gl.bindBuffer(gl.ARRAY_BUFFER, current_mouth_buf);
        gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(a_position);
        gl.drawArrays(gl.LINE_STRIP, 0, current_mouth_count);
      }
    }
  }
</script>

<script>
    // ðŸŽµ Play/Pause button logic (place this at the very end of the file)
    const btn   = document.getElementById('play-btn');
    const music = document.getElementById('bg-music');
  
    // start fetching/decoding so first click is instant
    try { music.load(); } catch (_) {}
  
    btn.onclick = async function () {
      // if it's autoplaying muted, just unmute for instant sound
      if (music.muted) {
        music.muted = false;
        music.volume = 0.6;
        this.textContent = "Pause Music ðŸ”‡";
        return;
      }
      try {
        if (music.paused) {
          await music.play();
          this.textContent = "Pause Music ðŸ”‡";
        } else {
          music.pause();
          this.textContent = "Play Music ðŸŽ¶";
        }
      } catch (e) {
        console.log('Audio error:', e);
      }
    };
  </script>
  

</html>
